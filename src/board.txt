(3)[8 6 7 2 5 4 3 0 1]


(3)[8 6 7 2 5 4 3 0 1] - hardest 3x3
Hamming - 31 moves, 17095 exp, 7693 unexp, 5.22s
Manhattan - 31 moves, 17946 exp, 9527 unexp, 6.22s
Linear Conflict - 31 moves, 5320 exp, 3016 unexx, 0.66s

(3)[8 7 6 5 4 3 2 1 0]
Hamming - 32, 18755 exp, 8284 unexp, 6.35s
Manhattan - 30 moves, 15635 exp, 7930 unexp, 4.79s
Linear Conflict - 30 moves, 9630 exp, 5473 unexp, 2.03s

(4)[12 6 4 3 13 15 7 0 8 9 11 2 14 5 1 10]
Hamming -
Manhattan - 84 moves, 11973 exp, 10542 unexp, 4.20s
Linear Conflict - 70 moves, 26145 exp, 23145 unexp, 21.58s

(4)[9 8 5 6 15 10 2 12 14 1 7 11 0 4 13 3]
Hamming -
Manhattan - 89 moves, 8522 exp, 7504 unexp, 2.56s
Linear Conflict - 87 moves, 5388 exp, 4673 unexp, 1.11s

(5)[15 9 24 11 7 13 20 6 12 3 8 22 19 17 10 14 2 1 23 18 0 16 5 4 21]
Hamming -
Manhattan -
Linear Conflict -

(5)[7 21 20 22 14 8 24 13 15 6 11 10 23 2 3 5 1 18 19 4 17 16 9 12 0]
Hamming -
Manhattan -
Linear Conflict -





    public int Manhattan(State newState){
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                for (int x = 0; x < size; x++) {
                    for (int y = 0; y < size; y++) {
                        if (goalState[x][y] == newState.board[i][j]) {
                            newState.h += Math.abs(x - i) + Math.abs(y - j);
                            break;
                        }
                    }
                }
            }
        }
        return newState.h;
    }

    public int LinearConflict(State newState)
    {
        int[] tiles = new int[size * size];
        int m = 0;
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++) {
                tiles[m] = newState.board[i][j];
                m++;
            }
        }
        int conflicts = 0;
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                int lin = i * size + j;
                if(tiles[lin] == 0)
                    continue;
                int a = (tiles[lin]-1) % size, b = (int)Math.floor((tiles[lin]-1)/size);
                if(j == a && i == b)
                    continue;

                if(j == a)
                {
                    for(int ii = Math.min(b, i); ii < Math.max(b, i); ii++)
                    {
                        int lin1 = ii * size + j;
                        int currCellX = (tiles[lin1]-1) % size;
                        if(currCellX == j) conflicts++;
                    }
                }else if(i == b)
                {
                    for(int jj = Math.min(a, j); jj < Math.max(a, j); jj++)
                    {
                        int lin2 = i * size + jj;
                        int currCellY = (int)Math.floor((tiles[lin2]-1) / size);
                        if(currCellY == i) conflicts++;
                    }
                }
            }
        }
        return Manhattan(newState) + conflicts * 2;
    }